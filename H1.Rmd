---
title: "H1"
output: html_document
date: '2022-04-10'
---

```{r include=FALSE}
#import libraries
install.packages("dplyr")
install.packages("tidyr")
install.packages("matrixcalc")
install.packages("zoo")
library(dplyr)
library(tidyr)
library(matrixcalc)
library(zoo)

```
Power consumption in USA:

The exercise deals with data from power stations in the United States on several contracts.

info cell: Reading the table Data

```{r}
#Reading Data
A <- read.delim("table.tsv")
A$DateTime <- as.POSIXct( A$megawatthours, tz = "EST", "%H:%M EST %m/%d/%Y" )

```
Data clearing:

1.Remove duplicate rows in the data frame

2.Complete missing values according to Last Observation in data frame

```{r}
A<-distinct(A) #1
na.locf(na.locf(A),fromLast=TRUE) #2
```
Cube construction:

The cube is bulid from dimension of time by days and the dimension of stations.

The measurable variable is Net generation
```{r}
# The dimensions of the cube are the Power stations and the dimension of date time.
data_cube<- with(A,cbind(BPAT=Net.generation,CISO	=Net.generation.1, CPLE=Net.generation.2,ERCO= Net.generation.3, FPL=Net.generation.4,ISNE= Net.generation.5,MISO= Net.generation.6,
                         NYIS =Net.generation.7 , PACW=Net.generation.8 , PJM=Net.generation.9 ,United_States_Lower = Net.generation.10,Date=as.integer(format(as.Date(A[,'DateTime']), "%Y%m%d"))))
```
Slicing:

Performing Slicing on Data cube, from all days to 07-14 Feb only.

```{r}
index<-which(data_cube[,'Date']>"20210206" & data_cube[,'Date']<"20210215" )
Silce_cube<-data_cube[index,]
```
Roll up:

Performing roll up - from a days and hours to days only.

```{r}
temp<-data_cube[index,]
rownames(temp) <- c(temp[,"Date"])
temp<-temp[,colnames(temp)!="Date"]
roll_up <-  rowsum(temp,row.names(temp))
data_mean<-rowMeans(roll_up[,1:11]) #Daily average performance
```
Plot:

Axis x - days

Axis y- Net generation

A graph that shows the daily average of the Net generation in the US


```{r}
data_frame<-tibble(data_mean)
days<- as.integer(substr(names(roll_up[,1]), nchar(names(roll_up[,1])) - 2 + 1, nchar(names(roll_up[,1]))) )
# create an empty plot
plot(1, type="n", xlab="", ylab="", xlim = c(days[1],days[8]), ylim=c(1505748 ,1900000 ))
# rearrange in a new, temporary dataframe
DF <- data.frame ( Time = days, Demand = data_frame)
# plot
lines( DF, col = 'darkorchid1', type = 'b' )
title(main = "Mean daily power generation in the US",
      xlab = "Days (07-14 Feb)", ylab = "Net generation",
      cex.main = 2,   font.main = 2, col.main = "darkorchid1")
```


```{r}
# The dimensions of the cube are the Power stations and the dimension of date time.
data_cube_q2<- with(A,cbind( CPLE=Net.generation.2, FPL=Net.generation.4,ISNE= Net.generation.5,
                         NYIS =Net.generation.7 , PJM=Net.generation.9 ,Time=as.integer(format(A[,'DateTime'], format = "%H"))))
data_cube_q2<-na.locf(data_cube_q2,fromLast=TRUE)
index_2<-which(data_cube_q2[,'Time']>9 & data_cube_q2[,'Time']<19 )
Silce_cube_2<-data_cube_q2[index_2,]


```


```{r}
temp_2<-data_cube_q2[index_2,]
rownames(temp_2) <- c(temp_2[,"Time"])
temp_2<-temp_2[,colnames(temp_2)!="Time"]
roll_up_2 <-  rowsum(temp_2,row.names(temp_2))


```


```{r}
# linear fit
LM <- list(  CPLE = NA,  FPL = NA,  ISNE = NA,  NYIS = NA, PJM = NA)
Lm_data<-data.frame (roll_up_2)
min_max_norm <- function(x) {
    (x - min(x)) / (max(x) - min(x))
}



mat1_data <- c(rep(c(1),9),c(10:18))
mat1 <- matrix(mat1_data,nrow=2,ncol=9,byrow=TRUE)
Demand_norm <- as.data.frame(lapply(Lm_data, min_max_norm))



"%^%" <- function(mat, power) 
  with(eigen(mat), vectors %*% (values^power * t(vectors))) 

# create an empty plot
plot(1, type="n", xlab="", ylab="", xlim = c(10,18), ylim=c(0 ,1))
demands <- seq(5)
for ( i in demands ) {
   # rearrange in a new, temporary dataframe
   DF <- data.frame ( Time =c(10:18), Demand = Demand_norm[,i] )
   # plot
   lines( DF, col = i, type = 'b' )
   # linear fit
   LM[ i ] <- ((t(mat1)%*% mat1)%^% (-1)) %*%(t(mat1))*(DF[2])
   #LM[[ i ]] <- lm( Demand ~ Time, data = DF)
   #a <- LM[[ i ]][1]
   #b <- coef(LM[[ i ]])[2]
   #abline(a, b, col = i, lw =2)
}



```


```{r}
```

